using System;

// пофиксить проблему с вводом не цифры для выборпа ячейки. Надо чтоб ввыводило напоминалку о неправильном вводе - готово
// чтоб нельзя было занять занятую ячейку - готово
// за нолик должен играть бот 

namespace O.X
{
    class Program  // почему если ставить паблик( но не работает с интернал хотя по логике должно) то ошибка в MethodForChiseCell(int a, char[,] Gird, ClassGird CG) с передачей ClassGird пропадает, не понятно.
    {
        static void Main(string[] args)
        {
            ClassLogicOfGame CLFG = new ClassLogicOfGame();
        }
    }
    public class ClassLogicOfGame
    {
        public ClassLogicOfGame()
        {
            int GamePlay = 1;
            int NumberOfPlayer = 1;    // Переменная отвечает за цифру которая обозначет символ которым будет ходитьт игрок.
            ClassGird CG = new ClassGird();
            DrowGird.gird(CG.GetSetGird);
            CoreOFTheProcess(GamePlay, CG, NumberOfPlayer);
        }

        public static int NumberOfTheCharChose()
        {
            //
            Console.WriteLine("Выберите ячейку числом от 1 до 9!\n");
            Console.WriteLine("--------------------------------------------------------------------------------------");
            string str = Console.ReadLine();
            if (Int32.TryParse(str, out int a))
            {
                a = Convert.ToInt32(str);
            }
            else
            {
                Console.WriteLine("Неверно введен символ выберите другой");
                a = NumberOfTheCharChose();
            }
            return a;
        }

        public static void ChangeOfNumberPlayer(ref int NumberOfPlayer)
        {
            if (NumberOfPlayer > 0)
            {
                NumberOfPlayer = NumberOfPlayer - 1;
            }
            else
            {
                NumberOfPlayer++;
            }
        }

        public static void CoreOFTheProcess (int GamePlay, ClassGird CG, int NumberOfPlayer)
        {
            while (GamePlay > 0)
            {
                int a = NumberOfTheCharChose();
                CG.GetSetGird = ChiseCell.MethodForChiseCell(a, CG.GetSetGird, ref NumberOfPlayer);
                HandlerOfTheGrid.MethodHandlerOfTheGrid(CG.GetSetGird);
                //Console.WriteLine("--------------------------------------------------------------------------------------");
            }
        }
    }
    public class ClassGird
        {
            public ClassGird ()
            {
                GetSetGird = GetGird;
            }
            private char[,] OriginalGrid = new char[,]
            {
            {'-','-','-' },
            {'-','-','-' },
            {'-','-','-' }
            };

            public char[,] GetGird
            {
                get 
                {
                    return OriginalGrid;
                }
            }   

            private char[,] WorkingGrid; // = new char[,] { };

            public char[,] GetSetGird
            {
                get
                {
                    return WorkingGrid;
                }
                set
                {
                    WorkingGrid = value;
                }
            }

    }

        public class ChiseCell                       // Разобраться почему без статика не работает //видать потомучто без статика нужно создать экземпляр
        {
            public static char[,] MethodForChiseCell(int a, char[,] Gird, ref int NumberOfPlayer)   
            {
                int columns = Gird.GetUpperBound(0) + 1;
                int rows = Gird.Length / columns;

                int NumberOFStroke = 0;

                for (int i = 0; i < 3; i++)
                {
                    for (int j = 0; j < rows; j++)
                    {
                        NumberOFStroke++;
                        if (a == NumberOFStroke)
                        {                     
                            if (Gird[i, j] != '-')
                            {
                                Console.WriteLine("Ячейка уже занята выберите другую ");
                            }
                            else
                            {
                                char result = NumberOfPlayer > 0 ? 'x' : 'o';
                                Gird[i, j] = result;
                            ClassLogicOfGame.ChangeOfNumberPlayer(ref NumberOfPlayer);
                        }
                        
                        } 
                     }
                }                 
                return Gird;
            }
        }    

    public class DrowGird
    {
        public static void gird(char[,] GGird)
        {
            char[,] Gird = GGird;

            int columns = Gird.GetUpperBound(0) + 1;
            int rows = Gird.Length / columns;
            for (int i = 0; i < columns; i++)
            {
                for (int j = 0; j < rows; j++)
                {
                    Console.Write(Gird[i, j]);
                }
                Console.WriteLine();
            }
        }
    }


    public class HandlerOfTheGrid
    {
        public static void MethodHandlerOfTheGrid(char [,] Grid)
        {
            int x = 0;
            foreach (char i in Grid) // Перебирает все ячейки и подсчитывает все в x
            {
                switch (i)
                {
                    case 'x':
                    case 'o':
                        x += 0; 
                        break;

                    case '-':
                        x += 1;
                        break;
                    default:
                        Console.WriteLine("Ошибка в классе MethodHandlerOfTheGrid ");
                        break;
                } 
                
            }
            DrowGird.gird(Grid);
            switch (x)  // Анализирует x и говрит продолжать игру или нет.
            {
                case (0):
                    Console.WriteLine($"Игра окончена, победил <>\n");
                    Console.WriteLine("Нажмите любую клавишу для завершения игры ");
                    Console.ReadKey();
                    // Process.GetCurrentProcess().Kill();
                    Environment.Exit(0); // = команда оканчивает процесс игры 
                    break;
                default:
                    
                    break;
            }
        }
    }
}

